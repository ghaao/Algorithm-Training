#pragma config(Sensor, S2,     light,               sensorLightActive)
#pragma config(Sensor, S1,     ultra,               sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#define THRESHOLD_ULTRA 30
#define THRESHOLD_LIGHT 60
#define THRESHOLD_TURN 110

float findAngle;
float findDist;
int back ;
int flag=0;
void PullUp(){
   float axis = 5.7;
   float tire = 2.8;

   //돌아서
   motor[motorA] = -10;
        motor[motorB] = 10;
   nMotorEncoder[motorA] = 0;
          nMotorEncoder[motorB] = 0;
          while( nMotorEncoder[motorB] <  (axis / tire * 20) );
   //앞으로
   nMotorEncoder[motorA] = 0;
          nMotorEncoder[motorB] = 0;
   motor[motorA] = 10;
        motor[motorB] = 10;
   while( nMotorEncoder[motorB] < 360 * 8 / ( 2 * 3.141582 * 2.8 ) );
   motor[motorA] = 0;
        motor[motorB] = 0;
        wait1Msec(500);
   //잡기
   nMotorEncoder[motorC] = 0;
   motor[motorC] = 10;
   while( nMotorEncoder[motorC] <  140 );
   motor[motorC] = 0;
   //뒤로
   nMotorEncoder[motorA] = 0;
          nMotorEncoder[motorB] = 0;
             motor[motorA] = 0;
        motor[motorB] = 0;
        wait1Msec(500);
   motor[motorA] = -10;
        motor[motorB] = -10;
   while( nMotorEncoder[motorB] > -( 360 * 8 / ( 2 * 3.141582 * 2.8 ) ) );
   //돌기
         motor[motorA] = 0;
        motor[motorB] = 0;
        wait1Msec(500);
   nMotorEncoder[motorA] = 0;
          nMotorEncoder[motorB] = 0;
   motor[motorA] = 10;
        motor[motorB] = -10;
          while( nMotorEncoder[motorB] >  -(axis / tire * 20) );
}
void drop(){
  //go
  motor[motorA]=20;
  motor[motorB]=20;
  wait1Msec(1000);
  //drop
    motor[motorA]=0;
  motor[motorB]=0;
   nMotorEncoder[motorC]=0;
  motor[motorC] =-10;
  while(nMotorEncoder[motorC] >-140);
  motor[motorC]=0;

}
int MoveFlag(int number, int forwardOrBack ){
   float tireAngle = 360 * 10 * number / ( 2 * 3.141582 * 2.8 );

   // 회전 각도 측정 초기화
          nMotorEncoder[motorA] = 0;
          nMotorEncoder[motorB] = 0;
  if(number ==0)
  {
    return 1;
  }

   if(forwardOrBack == 1 ){
      motor[motorA] = 20;
            motor[motorB] = 20;
   while( nMotorEncoder[motorA] < tireAngle){
         if( SensorValue(light) <= THRESHOLD_LIGHT ){
            back = nMotorEncoder[motorA];
            nMotorEncoder[motorA] = 0;
            motor[motorA] = -20;
                  motor[motorB] = -20;
            while( nMotorEncoder[motorA] > -back );
            return 0;
         }
      }
      motor[motorA] = 0;
            motor[motorB] = 0;
      nMotorEncoder[motorA] = 0;
             nMotorEncoder[motorB] = 0;
   } else{
      motor[motorA] = -20;
            motor[motorB] = -20;
      while( nMotorEncoder[motorA] > -tireAngle);
      motor[motorA] = 0;
            motor[motorB] = 0;
      nMotorEncoder[motorA] = 0;
             nMotorEncoder[motorB] = 0;
   }
   return 1;
}
void Back()
{
  float degree=0;
  //back from object to side line.
  nMotorEncoder[motorB] =0;
   motor[motorA] = -10;
   motor[motorB] = -10;
   while( nMotorEncoder[motorB] >-findDist);
    wait1Msec(1000);
      motor[motorA] = 0;
   motor[motorB] = 0;
    wait1Msec(1000);
   // line up the robot
   nMotorEncoder[motorB]=0;
    motor[motorA] = 10;
   motor[motorB] = -10;
   while( nMotorEncoder[motorB] >-findAngle);
        motor[motorA] = 0;
   motor[motorB] = 0;
    wait1Msec(1000);
   //and back to start line.
   if(flag != 0)
   {
     MoveFlag(flag,0);
   }

   //180 degree turn on the start line.
   nMotorEncoder[motorA]=0;
   degree =(5.7/2.8*180.0);
   motor[motorA] = 10;
     motor[motorB]=-10;
     while(nMotorEncoder[motorA] <degree);


      motor[motorA] = 0;
     motor[motorB]=0;
        wait1Msec(1000);// input the through object.
        drop();//drop the object.

        /* go to the first line.*/
      motor[motorA] =-20;
     motor[motorB]=-20;
         wait1Msec(1000);

         /*turn to the forward*/
      nMotorEncoder[motorB]=0;
   degree = (5.7/2.8*180.0);
   motor[motorA] = -10;
     motor[motorB]=10;
     while(nMotorEncoder[motorB] <degree);
        motor[motorA] = 0;
     motor[motorB]=0;
        wait1Msec(1000);// input the through object.

}

   //if you find the object, return true. But if you didn't find the object, return false.
int detect(){
 float  axis = 5.7;
 float   tire = 2.8;
  findAngle=0;
  findDist=0;
   motor[motorA] = -5;
         motor[motorB] = 5;


          nMotorEncoder[motorA] = 0;
          nMotorEncoder[motorB] = 0;
  // search from 0 degree to 90 degree
  while( nMotorEncoder[motorB] <  (axis / tire * 90) ) {
           if (SensorValue(ultra) <= THRESHOLD_ULTRA){
                 findAngle = nMotorEncoder[motorB];
       while(SensorValue(ultra) <= THRESHOLD_ULTRA);
       findAngle = (findAngle + nMotorEncoder[motorB])/2-10 ;
       motor[motorA] = 10;
             motor[motorB] = -10;
       while( nMotorEncoder[motorB] > findAngle );
       motor[motorA] = 0;
             motor[motorB] = 0;
                 nMotorEncoder[motorB] = 0;
              break;
           }
        }
        // if you find the object, you go to object.
   if( findAngle != 0 ){
      nMotorEncoder[motorB] = 0;
           motor[motorA] = 10;
           motor[motorB] = 10;
           while( SensorValue(ultra) >= 15.0 );
            motor[motorA] = 0;
         motor[motorB] = 0;
           findDist = nMotorEncoder[motorB];
           nMotorEncoder[motorB] = 0;
      return 1;
   }
   //if you don't find the object
    nMotorEncoder[motorB] = 0;
   motor[motorA] = 5;
         motor[motorB] = -5;
   while( nMotorEncoder[motorB] > -(axis / tire * 90) );
   motor[motorA] = 0;
         motor[motorB] = 0;
   nMotorEncoder[motorB] = 0;
   return 0;
}

task main(){

   // Detect object while robot reach the black line (end point)
   while(SensorValue(light) >= THRESHOLD_LIGHT) {
      if( detect() ){
         PullUp();
         Back();
         MoveFlag(flag, 1);
      }else{
         if( MoveFlag(1,1) != 1)
            break;
            flag++;
      }
   }
   MoveFlag(flag,0);
   PlaySound(soundBeepBeep);
}